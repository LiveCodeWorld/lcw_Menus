[{"created":"2025-01-25T20:54:29.305Z","text":"This Guide is about [[Menu Tool]]s. Our main use for these at the moment is to enable [[Guide Specific Tooling]] stored within the body of the Guide. We look to our first implmentation of this with the parsing of the [[Guide Tools]] tiddler whene the Guide is loaded by a GuideApp.\n\n{{$:/plugins/nico/projectify/ui/dashboard/Dashboard}}\n\nYou may wish to use the [[Git Tools]] that we make available via the [[GuideApp]].\n\n<$button type=\"button\" class=\"btn btn-info btn-sm\">\n  EditScript of stack 'lib_TiddlyMessage'\n  <$callLivecode message=\"EditScript stack 'lib_TiddlyMessage'\"/>\n</$button>","title":"About","modified":"2025-03-13T16:12:17.080Z"},{"created":"2025-01-27T21:27:01.509Z","text":"","tags":["Inbox","todo","Milestone"],"modified":"2025-01-27T21:29:44.571Z","title":"First Demo","due":"20250128235959999"},{"created":"2025-03-13T16:04:20.926Z","text":"**Guide Specific Tooling** are tools that are contained and load with the Guide. They are embedded within the single-file [[Monad]]. As an example a Guide regarding artificial intelligence may include a set of core navigation menus to usefull web sites, and tools that empower custom agents to interact with the sites content - so the ai may be trained specifically to answer questions on the specialist field concerned.\n\nIn this way a [[Guide is Alive]] - it is a fully fledged appllcation which you can view either as an interactive document, or as an application with rich documentation support - in reality it is a blending of code and content into a single format.","title":"Guide Specific Tooling","modified":"2025-03-13T16:09:05.548Z","type":"text/markdown"},{"created":"2025-01-21T22:09:20.882Z","text":"A LiveButton is a [[TiddlyButton]] that uses javascript to call Livecode. The `<$hello>` test-action widget is registered:\n\n<$hello/>\n\nTiddlyWiki does not directly support inline JavaScript execution via widgets. Instead, JavaScript must either be embedded in a custom plugin (or maybe executed via an appropriate API like tm-sendmessage???).\n\n! Best Practice\nThe [[$:/plugins/custom/ExecuteJavaScript]] macro exports `exports.callLivecode = CallLivecodeWidget;`, which can be called in a button with `<$callLivecode>`. As you can see by the javascript this (currntly) simply calls the [[tiddlyButton_Call]] function in LiveCode. The idea I believe was to obtain a result in javascript - which as i remember is not going to work (yet). Here are some `callLivecode` button examples:\n\n```\n<$button>\n  $callLivecode\n  <$callLivecode/>\n</$button>\n```\n\n<$button>\n  $callLivecode\n  <$callLivecode/>\n</$button>\n\n<$button>\n  Send \"Hello\" with $callLivecode\n  <$callLivecode message=\"Hello\"/>\n</$button>\n\n<$vars dynamicMessage=\"This is a Dynamic Message from TW\">\n  <$button>\n    Send Dynamic Message with $callLivecode\n    <$callLivecode message=<<dynamicMessage>>/>\n  </$button>\n</$vars>\n\n! Live Actions\nHere are some examples of LiveButtons that interact with Livecode. These ones have been styled using the ShirazPlugin.\n\n<$button type=\"button\" class=\"btn btn-info btn-sm\">\n  EditScript of stack 'lib_TiddlyMessage'\n  <$callLivecode message=\"EditScript stack 'lib_TiddlyMessage'\"/>\n</$button>\n\n<$link overrideClass=\"btn btn-warning\" to=\"Warning\">Link to Warning</$link>\n\n<$button type=\"button\" class=\"btn btn-danger btn-sm\">\n  HkeyEdit 'C tiddlyButton_Call'\n  <$callLivecode message=\"HkeyEdit 'C tiddlyButton_Call'\"/>\n</$button>\n\n! See also\nSome experiments regarding asynchrounous interacctions between LiveCode and TiddlyWiki:\n\n* [[Experimental Messaging]]\n\nThe result of these tests are displayed in the [[Test]] tiddler, and sometimes logged in the [[test-log]] tiddler.\n\n```\n<$button>\n  $wikiscript with Hello\n  <$wikiscript message=\"Hello\"/>\n</$button>\n```\n\nSee also work in progress using transclusion for multiline text only messages:\n\n* [[Multiline LiveButton Messages]]","title":"LiveButton","modified":"2025-03-11T15:42:00.383Z"},{"created":"2025-03-13T16:38:52.538Z","text":"A menu [[controller]] (''mController'') is a Livecode scriptonly stack script (siimple text file) that is all we need to autogenerate a menu directed at a traget ([[mTarget]]). The code is essentially a [[controller]] that can be parsed to generate a menu-style interface.","title":"mController","modified":"2025-03-13T16:41:03.404Z"},{"created":"2025-03-13T15:44:17.392Z","text":"The ''Menu Tools'' contained within the [[lcw_Menus]] project have been in use and involved over the last 35 years. They are complex and evolved code without a focus on robustness and simplicity - they were always intended to apply wiki like participatory practice to code.\n\n## Aims\nThe aims of these tools are to:\n\n1. Auto UX - where code generates the UX with minimal or no extra effort\n1. Reduce visual clutter - menus which auto-hide give focus to informative content\n1. Minimal interface. Minimal Code. Where less is more.\n\nWe aim to realise these objectives by focussing the ux on CinematicContent and including all non-essential functionailty in MicroServiceMenus that can be loaded dynamically as we read.\n","title":"Menu Tool","modified":"2025-03-13T16:11:56.129Z","type":"text/markdown"},{"created":"2025-03-13T16:19:18.210Z","text":"An ''mGroup'' or [[Menu Group]] is a Livecode group that contains a set of buttons one for each menu. This structure allows us to code for cross platform menus and interact with the data and code in a visual way. however each menu is complex, and a group of several menus comprises most of the code for an entire application - on top of which the ux for a well fucntioning set of menus includes a great deal of visual feedback - checking of items and disabling of others - this all requires coding.\n\n# Simplicity\nWe aim to provide a set of visual tools that make it incredibly simple to construct these menus. Our aim is to build upon the current [[Menu Tools}] to provide a wiki of microservices that can be forked and rearranged to create full blown menus together with documentation for each feature. In this way creating the application should be as simple as writing in a wiki. This is a complex form of writing, but a simple form of coding.\n\n# Data Structure\nOur aim is create a standard data structure for menus and menu groups. This data structure in effect encapsulates the main structure fo an application - both its functioanilty (the code) and how we present or reveal this functionailty to the user. Given this data structure an application can choose how to display the tooling - whether that be a macOS style mentor, or a mobile application or a web site consisting of pages and buttons. \n\n# Polyglot Abstraction\nIn this way we abstract the functionaility into an organised set of wiki (html) pages, and a suite of microservices that can be implemented in any language. We expect application to fetch, or call these micorservices in powerful new ways.","title":"mGroup","modified":"2025-03-13T16:38:39.816Z"},{"created":"2025-03-13T16:11:01.170Z","text":"The menuTarget or mTarget is the target of the tools action. This gives the tool focus and context. A [[menu Tool]] is structured as a generic piece of code that can be directed at different targets. In terms of the classic [[Model View Controller]] computer science paradigm we can apply a controller to different views - or in our case a menu controller ([[mController]]) can be applied to different views or [[menu_Target]]s ([[mTarget]].\n\n## Menu Targets are Views\n\n# Some Ambiguity\nWe have experimented with allowing values other than object references to Livecode views to be referenced by mTarget - for instance a projects name. However we should probably simplify the code and menatl model by insisting on a valid object reference for mTarget as errors creep in with nested controllers assuming an object reference and then throwing erros when it does nto find one.","title":"mTarget","modified":"2025-03-13T16:18:58.734Z"},{"created":"2025-01-27T21:27:39.027Z","text":"","tags":["Inbox","todo","Milestone"],"modified":"2025-01-27T21:28:44.950Z","title":"Project Release","due":"20250203235959999"},{"created":"2025-01-27T21:25:06.229Z","text":"","tags":["Inbox","todo","Milestone"],"modified":"2025-01-27T21:29:02.052Z","title":"Project Specification","due":"20250127235959999"},{"created":"2025-01-27T21:24:24.684Z","text":"<<timeline-vertical filter:\"[tag[Milestone]]\" date:\"due\" dateformat:\"mmm DDth\">>","title":"Roadmap","modified":"2025-01-27T21:24:27.545Z"},{"created":"2025-01-25T20:54:54.134Z","text":"<<interstitial>>\n\n@@.interstitial\n* ''15:32'' Menus and ruby style defaults are a nightmare. Lets move to minimal type safe structures?\n* ''16:10'' See description of core concepts - [[mTarget]], [[tObject]],  [[mController]] and [[mGroup]]\n@@","title":"Working on","modified":"2025-03-13T16:10:50.838Z"}]